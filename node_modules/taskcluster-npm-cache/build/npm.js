"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

module.exports = init;
var temp = _interopRequire(require("promised-temp"));

var del = _interopRequire(require("delete"));

var denodeify = _interopRequire(require("denodeify"));

var eventToPromise = _interopRequire(require("event-to-promise"));

var Debug = _interopRequire(require("debug"));

var run = _interopRequire(require("./run"));

var format = require("util").format;
var fs = _interopRequire(require("mz/fs"));

var fsPath = _interopRequire(require("path"));

var download = _interopRequire(require("download"));

var downloadStatus = _interopRequire(require("download-status"));

var debug = Debug("npm-cache:workspace");

var Workspace = (function () {
  function Workspace(dir) {
    this.dir = dir;
  }

  _prototypeProperties(Workspace, null, {
    destroy: {

      /**
      Destroy all temporary assets created.
      */
      value: function destroy() {
        return regeneratorRuntime.async(function destroy$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              context$2$0.next = 2;
              return denodeify(del)(this.dir, { force: true });
            case 2:
            case "end":
              return context$2$0.stop();
          }
        }, null, this);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    extract: {

      /**
      Extract package from remote target into given directory.
      */
      value: function extract(url, target) {
        var path, req;
        return regeneratorRuntime.async(function extract$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              debug("extract", { url: url, target: target });
              path = fsPath.join(target, "node_modules.tar.gz");
              req = download().get(url).dest(target).use(downloadStatus());
              context$2$0.next = 5;
              return denodeify(req.run).call(req);
            case 5:
              context$2$0.next = 7;
              return run("tar", ["zxf", path], { cwd: target });
            case 7:
            case "end":
              return context$2$0.stop();
          }
        }, null, this);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    install: {

      /**
      Update or install node modules associated with the package json URL
      provided.
      */
      value: function install(pkg) {
        var pkgPath;
        return regeneratorRuntime.async(function install$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              pkgPath = fsPath.join(this.dir, "package.json");
              context$2$0.next = 3;
              return fs.exists(pkgPath);
            case 3:
              if (!context$2$0.sent) {
                context$2$0.next = 5;
                break;
              }
              throw new Error("Cannot run install twice (package.json exists)");
            case 5:
              context$2$0.next = 7;
              return fs.writeFile(pkgPath, JSON.stringify(pkg));
            case 7:
              context$2$0.next = 9;
              return run("npm", ["install"], {
                cwd: this.dir
              });
            case 9:
            case "end":
              return context$2$0.stop();
          }
        }, null, this);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    exportTar: {

      /**
      Create a new tar containing node_modules and return path.
      */
      value: function exportTar() {
        var modulesPath, exportPath;
        return regeneratorRuntime.async(function exportTar$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              modulesPath = fsPath.join(this.dir, "node_modules");
              context$2$0.next = 3;
              return fs.exists(modulesPath);
            case 3:
              if (context$2$0.sent) {
                context$2$0.next = 5;
                break;
              }
              throw new Error("No modules to export (node_modules missing)");
            case 5:
              exportPath = fsPath.join(this.dir, "node_modules.tar.gz");
              context$2$0.next = 8;
              return run("tar", ["czf", exportPath, "node_modules"], {
                cwd: this.dir
              });
            case 8:
              return context$2$0.abrupt("return", exportPath);
            case 9:
            case "end":
              return context$2$0.stop();
          }
        }, null, this);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Workspace;
})();

/**
Initialize the workspace with a temp directory.
*/
function init() {
  var dir;
  return regeneratorRuntime.async(function init$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return temp.mkdir("npm-cache");
      case 2:
        dir = context$1$0.sent;
        debug("create: %s", dir);
        return context$1$0.abrupt("return", new Workspace(dir));
      case 5:
      case "end":
        return context$1$0.stop();
    }
  }, null, this);
}


// XXXAus: We should get rid of this in favor of a platform agnostic
//         module.


// XXX: We may want to sanitize parts of this such as scripts which
//      effectively lets you run untrusted code.


// XXXAus: We should get rid of this in favor of a platform agnostic
//         module.
//# sourceMappingURL=npm.js.map