"use strict";

var _slicedToArray = function (arr, i) {
  if (Array.isArray(arr)) {
    return arr;
  } else {
    var _arr = [];

    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);

      if (i && _arr.length === i) break;
    }

    return _arr;
  }
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

var spawn = require("mz/child_process").spawn;
var wait = _interopRequire(require("event-to-promise"));

var assert = _interopRequire(require("assert"));

module.exports = function callee$0$0(cmd) {
  var argv,
      opts,
      proc,
      _ref,
      _ref2,
      exit,
      args$1$0 = arguments;
  return regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        argv = args$1$0[1] === undefined ? [] : args$1$0[1];
        opts = args$1$0[2] === undefined ? {} : args$1$0[2];
        assert(Array.isArray(argv), "argv must be an array");
        opts.stdio = opts.stdio || "inherit";
        proc = spawn(cmd, argv, opts);
        context$1$0.next = 7;
        return wait(proc, "exit");
      case 7:
        _ref = context$1$0.sent;
        _ref2 = _slicedToArray(_ref, 1);
        exit = _ref2[0];
        if (!(exit != 0)) {
          context$1$0.next = 12;
          break;
        }
        throw new Error("Failed running " + cmd + " " + argv.join(" ") + " code: " + exit);
      case 12:
      case "end":
        return context$1$0.stop();
    }
  }, null, this);
};
//# sourceMappingURL=run.js.map